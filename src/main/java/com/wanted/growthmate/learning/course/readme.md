# 📘 Course Domain

[카테고리 & 강좌]

- 1차
    - 로그인/역할/결제상태에 따른 UI 표시 조건부
        - 강좌 목록 & 상세에 가격 표시
        - 강사 로그인 시 버튼 [ 강좌 관리 ]
    - 무료 강의 정책에 대한 고민 필요
        - DB=숫자(0), UI=‘무료’
    - 강좌 페이지 조회/생성/수정/삭제
        - 작성중, 게시완료 뱃지
        - [섹션 추가] 버튼 ← 강좌 입력 전이라도 가능?
- 2차
    - 프리뷰(Preview)
- 3차
    - 카테고리 crud

###
# 1차 구현을 위해 내가 공부한 것

## CRUD 구현

- **업데이트 방식의 선택**
    - *더티체킹(권장)*: `findById → set…` (+ `@Transactional`) → 커밋 시 자동 `UPDATE`.
- **Optional/예외 처리**
    - `findById(...).orElseThrow(...)`로 “없음”을 명확히. `null` 반환 금지.
    - 서비스는 도메인 예외 던지고, 컨트롤러에서 404/400 등으로 매핑.
- **트랜잭션 경계**
    - 서비스 메서드에 `@Transactional`. 더티체킹·플러시·롤백 보장.
- **낙관적 락(@Version)**
    - 로드→변경→커밋 시 자동 `WHERE id AND version`.
    - “변경 없음” 판정은 버전/필드 비교로 처리
    - 동시 발행/수정 충돌 시 409 처리.
- **ID/제네릭 일치**
    - `JpaRepository<Post, Integer>` ↔ `@Id Integer`(또는 `Long/long`) 타입 일치 필수.
- **응답 구성**
    - 요청 DTO로 응답 만들지 말고 **엔티티 실제 값**에서 읽어 반환(반영값 보장).

---

## 테스트

- **UI 없이 서비스 로직을 빠르게 검증** → 화면에 끌려가지 않고 **도메인/규칙 중심**으로 사고가 고정됨.
- 테스트가 **설계 가이드** 역할: “무엇이 일어나야 하는가?”를 먼저 고정하고 코드를 거기에 맞춤.

---

## **유스케이스**

### 1) 유스케이스로 본 계층의 역할과 존재 이유

- **Controller**
    - 요청 파싱 & 1차 검증(형식, 필수값)
    - **도메인 파라미터로 변환**(id, enum, 값 객체 등)
    - 외부 세계 → 애플리케이션 경계 책임
- **Service**
    - 트랜잭션 경계
    - **도메인 규칙 적용 / 도메인 예외 던짐**
    - Repository 협력해 **모델 조립**
    - View에 필요한 **읽기 전용 DTO(쿼리/뷰 모델)로 변환**
- **Repository**
    - 영속성 접근(도메인 객체 로드/저장)
    - 쿼리 최적화(필요 시 읽기 전용 프로젝션)

> 정리: Controller는 “들어오는 것을 정제”, Service는 “규칙을 적용해 결과를 만들고 표현 형태로 변환”, Repository는 “데이터를 안전하게 가져오기/저장하기”
>

### 2) 카테고리의 역할(“강좌 생성의 입력 도우미”)

- 카테고리는 **강좌 생성 시 선택 목록 제공**이 주 목적
- 비즈니스 규칙이 단순하면 별도 서비스 로직 최소화
- 조회는 **읽기용 DTO/프로젝션**으로 가볍게(이름, id, 정렬 순서)

### 3) 읽기용 DTO(뷰 모델)를 고민한 이유

- 화면은 엔티티 그대로가 아닌 **표시 전용 데이터**를 요구
- 장점: API 응답이 안정적, 퍼포먼스 최적화, 프런트 분기 단순화
- 예: `CourseListItem { courseId, title, effectivePrice, categoryName, viewerFlags… }`

### 4) 책임 경계가 명확해졌을 때의 효과

- 테스트 포인트가 뚜렷(Controller: 파싱/검증, Service: 규칙/예외, Repo: 쿼리)
- 변경 영향 범위가 작아짐(표시 변경은 DTO만 수정)
- 도메인 규칙 누락/중복 감소

---

## **조회용 API 설계(읽기모델)**

- 메인 페이지에서 로그인한 사용자가 코스 목록을 요청했을 때 서버가 내려주는 **표시용 응답 예시**

### API 계약(예시)

- `GET /api/users/me` → `{ id, name, roles, ... }`
- `GET /api/courses?viewer=me`

    ```json
    [
      {
        "courseId": 101,
        "title": "DDD 입문",
        "listPrice": 39000,
        "effectivePrice": 0,
        "viewer": {
          "roleFlags": ["INSTRUCTOR"],
          "enrollmentStatus": "PAID",
          "hasAccess": true,
          "canManage": true}
      }
    ]
    
    ```

- `/api/users/me`로 로그인 상태/역할 확인(쿠키 기반 세션/토큰).
- `/api/courses?viewer=me`로 코스 목록 요청 → 각 코스에 `viewer` 포함해 응답.
- 프론트는 `viewer`만 보고 “관리 버튼/수강중/가격” 등을 분기.
- 프론트(JS)는 **표시만 결정**하면 됨:

    ```java
    if (c.viewer.canManage) showManageButton(); //상단 강좌관리 버튼 표시
    if (c.viewer.hasAccess) showBadge('수강중');
    else showPrice(c.effectivePrice === 0 ? '무료' : formatKRW(c.effectivePrice));
    ```
---

# 2차 — 프리뷰

**1) 초안/발행 상태 + 프리뷰 토큰 링크**

- **무엇**: `status = DRAFT|PUBLISHED`, 초안일 때만 `?previewToken=...`으로 접근.
- **왜**: 공개 전 검수·공유를 안전하게.
- **어떻게**: 강좌 테이블에 `status`, `preview_token`, `preview_expires_at`. 미들웨어에서 `status==DRAFT`면 토큰 검증.
- **DoD**: 토큰 없이 DRAFT 접근 403, 유효 토큰은 열람 OK(로그 남김).

**2) 미노출 보장**

- **무엇**: 프리뷰 페이지는 검색/목록에 노출 금지.
- **왜**: 실수로 유출 방지.
- **어떻게**: 목록/검색 쿼리에서 `status=PUBLISHED`만, 프리뷰 응답 헤더 `X-Robots-Tag: noindex`.
- **DoD**: DRAFT는 검색/목록/추천 어느 곳에도 보이지 않음.

**3) 프리뷰 배지·워터마크 + 경고 배너**

- **무엇**: 상단 “프리뷰 모드” 배너, 워터마크.
- **왜**: 운영/사용자 혼동 방지.
- **어떻게**: `viewer.preview=true`일 때 UI 배지 렌더.
- **DoD**: 스크린샷만 봐도 프리뷰임을 식별 가능.

**4) 검수 체크리스트 자동화**

- **무엇**: 제목 길이, 썸네일 비율, 섹션·강의 최소 개수 등 룰 점검.
- **왜**: 발행 품질 보장.
- **어떻게**: `POST /courses/{id}/validate` → 규칙별 결과 배열 반환.
- **DoD**: Fail 항목이 0일 때만 “발행” 버튼 활성.

**5) 프리뷰 공유 제어(옵션)**

- **무엇**: 만료시간/1회용·IP 제한.
- **왜**: 보안/관리.
- **어떻게**: 토큰 클레임에 제한 정보 포함.
- **DoD**: 만료/초과 시 403 + 사유 로그.

**6) A/B 프리뷰(간단 버전)**

- **무엇**: 썸네일/타이틀 B안 미리보기.
- **왜**: 발행 전 선택 도움.
- **어떻게**: `?v=B` 파라미터로 변형안 로드, 저장은 초안만.
- **DoD**: A/B 전환 시 즉시 미리보기 반영.

---

# 3차 — 카테고리 CRUD

**1) 카테고리 스키마 정립(단일/계층)**

- **무엇**: `categories(id, name, slug, parent_id NULLABLE, sort_order, is_active)`
- **왜**: 정렬/URL/비활성 관리.
- **어떻게**: `UNIQUE(slug)`, `UNIQUE(parent_id, name)`, 인덱스(parent_id, sort_order).
- **DoD**: 동일 부모 내 중복 불가, 정렬 일관.

**2) 관리자 전용 CRUD + 정렬 변경**

- **무엇**: Admin API로 생성/수정/삭제/정렬 변경.
- **왜**: 운영 효율.
- **어떻게**: `@PreAuthorize('hasRole(ADMIN)')`, 소프트 삭제(`deleted_at`) 권장.
- **DoD**: 정렬 변경이 리스트 즉시 반영, 삭제 시 코스 매핑 규칙 동작.

**3) 카테고리-강좌 매핑 규칙**

- **무엇**: 강좌에 `category_id`(FK) 또는 다중 선택이면 중간 테이블.
- **왜**: 조회/필터 정확성.
- **어떻게**: 강좌 생성/수정 시 `category_id` 존재/활성 검증.
- **DoD**: 비활성/삭제 카테고리로는 강좌 저장 불가(400).

**4) 슬러그 & SEO**

- **무엇**: `/courses?category=backend` 같은 슬러그 기반.
- **왜**: 링크 안정성/가독성.
- **어떻게**: 이름 변경 시 슬러그 보존 또는 리다이렉트 테이블.
- **DoD**: 기존 링크 301 유지.

**5) 사용량 카운터·캐싱**

- **무엇**: `course_count` 캐시 컬럼/뷰.
- **왜**: 목록 필터에 숫자 표시, 성능.
- **어떻게**: 트리거/비동기 집계 or 뷰 리프레시.
- **DoD**: 카테고리 목록에 실시간(또는 준실시간) 카운트 노출.

**6) 이동/병합(운영 기능, 옵션)**

- **무엇**: 카테고리 재배치/병합 시 강좌 이관.
- **왜**: 운영 중 구조 변경 대응.
- **어떻게**: 트랜잭션으로 일괄 업데이트 + 감사 로그.
- **DoD**: 레퍼런스 무결성 유지, 이관 결과 리포트.